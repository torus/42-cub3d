(use gauche.array)
(use srfi-27)

(define *width* 21)
(define *height* 21)

(define *array* (make-array (shape 0 *width* 0 *height*) #f))

(define (print-array)
  (let loop ((y 0))
    (if (= y *height*)
        'done
        (begin
          (let loop ((x 0))
            (if (= x *width*)
                (newline)
                (begin
                  (if (and (= x (- *width* 2))
                           (= y (- *height* 2)))
                      (display "2")
                      (display (if (array-ref *array* x y) "0" "1")))
                  (loop (+ x 1)))))
          (loop (+ y 1))))))

(define (compose heads tail)
  (if (null? heads)
      tail
      (compose (cdr heads) (cons (car heads) tail))))

(define (pop-nth heads tail n)
  (if (eq? n 0)
      (values (compose heads (cdr tail)) (car tail))
      (pop-nth (cons (car tail) heads) (cdr tail) (- n 1))))

(define (dig x y)
  (array-set! *array* x y #t)

  (let ((rand (random-integer 24))
        (procs (list  (^[] (when (and (> x 1)
                                      (not (array-ref *array* (- x 2) y)))
                             (array-set! *array* (- x 1) y #t)
                             (dig (- x 2) y)))
                      (^[] (when (and (< x (- *width* 2))
                                      (not (array-ref *array* (+ x 2) y)))
                             (array-set! *array* (+ x 1) y #t)
                             (dig (+ x 2) y)))
                      (^[] (when (and (> y 1)
                                      (not (array-ref *array* x (- y 2))))
                             (array-set! *array* x (- y 1) #t)
                             (dig x (- y 2))))
                      (^[] (when (and (< y (- *height* 2))
                                      (not (array-ref *array* x (+ y 2))))
                             (array-set! *array* x (+ y 1) #t)
                             (dig x (+ y 2)))))))
    (let-values (((rest proc) (pop-nth () procs (logand rand 3))))
      (proc)
      (let-values (((rest proc) (pop-nth () rest (logand (ash rand 3) 3))))
        (proc)
        (let-values (((rest proc) (pop-nth () rest (logand (logand (ash rand 2) 1) 3))))
          (proc)
          ((car rest)))))))

(define (main args)
  (let ((width (cadr args))
        (height (caddr args)))
    (set! *width* (x->number width))
    (set! *height* (x->number height))
    (set! *array* (make-array (shape 0 *width* 0 *height*) #f))
    (dig 1 1)
    (print-array)))
